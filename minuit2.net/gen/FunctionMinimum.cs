//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (https://www.swig.org).
// Version 4.3.0
//
// Do not make changes to this file unless you know what you are doing - modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------


public class FunctionMinimum : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal FunctionMinimum(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(FunctionMinimum obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  internal static global::System.Runtime.InteropServices.HandleRef swigRelease(FunctionMinimum obj) {
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new global::System.ApplicationException("Cannot release ownership as memory is not owned");
      global::System.Runtime.InteropServices.HandleRef ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.Dispose();
      return ptr;
    } else {
      return new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
    }
  }

  ~FunctionMinimum() {
    Dispose(false);
  }

  public void Dispose() {
    Dispose(true);
    global::System.GC.SuppressFinalize(this);
  }

  protected virtual void Dispose(bool disposing) {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Minuit2PINVOKE.delete_FunctionMinimum(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  }

  public FunctionMinimum(SWIGTYPE_p_MinimumSeed seed, double up) : this(Minuit2PINVOKE.new_FunctionMinimum__SWIG_0(SWIGTYPE_p_MinimumSeed.getCPtr(seed), up), true) {
    if (Minuit2PINVOKE.SWIGPendingException.Pending) throw Minuit2PINVOKE.SWIGPendingException.Retrieve();
  }

  public FunctionMinimum(SWIGTYPE_p_MinimumSeed seed, SWIGTYPE_p_std__vectorT_ROOT__Minuit2__MinimumState_t states, double up, FunctionMinimum.Status status) : this(Minuit2PINVOKE.new_FunctionMinimum__SWIG_1(SWIGTYPE_p_MinimumSeed.getCPtr(seed), SWIGTYPE_p_std__vectorT_ROOT__Minuit2__MinimumState_t.getCPtr(states), up, (int)status), true) {
    if (Minuit2PINVOKE.SWIGPendingException.Pending) throw Minuit2PINVOKE.SWIGPendingException.Retrieve();
  }

  public FunctionMinimum(SWIGTYPE_p_MinimumSeed seed, SWIGTYPE_p_std__vectorT_ROOT__Minuit2__MinimumState_t states, double up) : this(Minuit2PINVOKE.new_FunctionMinimum__SWIG_2(SWIGTYPE_p_MinimumSeed.getCPtr(seed), SWIGTYPE_p_std__vectorT_ROOT__Minuit2__MinimumState_t.getCPtr(states), up), true) {
    if (Minuit2PINVOKE.SWIGPendingException.Pending) throw Minuit2PINVOKE.SWIGPendingException.Retrieve();
  }

  public void Add(MinimumState state, FunctionMinimum.Status status) {
    Minuit2PINVOKE.FunctionMinimum_Add__SWIG_0(swigCPtr, MinimumState.getCPtr(state), (int)status);
    if (Minuit2PINVOKE.SWIGPendingException.Pending) throw Minuit2PINVOKE.SWIGPendingException.Retrieve();
  }

  public void Add(MinimumState state) {
    Minuit2PINVOKE.FunctionMinimum_Add__SWIG_1(swigCPtr, MinimumState.getCPtr(state));
    if (Minuit2PINVOKE.SWIGPendingException.Pending) throw Minuit2PINVOKE.SWIGPendingException.Retrieve();
  }

  public SWIGTYPE_p_MinimumSeed Seed() {
    SWIGTYPE_p_MinimumSeed ret = new SWIGTYPE_p_MinimumSeed(Minuit2PINVOKE.FunctionMinimum_Seed(swigCPtr), false);
    return ret;
  }

  public SWIGTYPE_p_std__vectorT_ROOT__Minuit2__MinimumState_t States() {
    SWIGTYPE_p_std__vectorT_ROOT__Minuit2__MinimumState_t ret = new SWIGTYPE_p_std__vectorT_ROOT__Minuit2__MinimumState_t(Minuit2PINVOKE.FunctionMinimum_States(swigCPtr), false);
    return ret;
  }

  public MnUserParameterState UserState() {
    MnUserParameterState ret = new MnUserParameterState(Minuit2PINVOKE.FunctionMinimum_UserState(swigCPtr), false);
    return ret;
  }

  public MnUserParameters UserParameters() {
    MnUserParameters ret = new MnUserParameters(Minuit2PINVOKE.FunctionMinimum_UserParameters(swigCPtr), false);
    return ret;
  }

  public MnUserCovariance UserCovariance() {
    MnUserCovariance ret = new MnUserCovariance(Minuit2PINVOKE.FunctionMinimum_UserCovariance(swigCPtr), false);
    return ret;
  }

  public MinimumState State() {
    MinimumState ret = new MinimumState(Minuit2PINVOKE.FunctionMinimum_State(swigCPtr), false);
    return ret;
  }

  public MinimumParameters Parameters() {
    MinimumParameters ret = new MinimumParameters(Minuit2PINVOKE.FunctionMinimum_Parameters(swigCPtr), false);
    return ret;
  }

  public SWIGTYPE_p_MinimumError Error() {
    SWIGTYPE_p_MinimumError ret = new SWIGTYPE_p_MinimumError(Minuit2PINVOKE.FunctionMinimum_Error(swigCPtr), false);
    return ret;
  }

  public SWIGTYPE_p_FunctionGradient Grad() {
    SWIGTYPE_p_FunctionGradient ret = new SWIGTYPE_p_FunctionGradient(Minuit2PINVOKE.FunctionMinimum_Grad(swigCPtr), false);
    return ret;
  }

  public double Fval() {
    double ret = Minuit2PINVOKE.FunctionMinimum_Fval(swigCPtr);
    return ret;
  }

  public double Edm() {
    double ret = Minuit2PINVOKE.FunctionMinimum_Edm(swigCPtr);
    return ret;
  }

  public int NFcn() {
    int ret = Minuit2PINVOKE.FunctionMinimum_NFcn(swigCPtr);
    return ret;
  }

  public double Up() {
    double ret = Minuit2PINVOKE.FunctionMinimum_Up(swigCPtr);
    return ret;
  }

  public bool IsValid() {
    bool ret = Minuit2PINVOKE.FunctionMinimum_IsValid(swigCPtr);
    return ret;
  }

  public bool HasValidParameters() {
    bool ret = Minuit2PINVOKE.FunctionMinimum_HasValidParameters(swigCPtr);
    return ret;
  }

  public bool HasValidCovariance() {
    bool ret = Minuit2PINVOKE.FunctionMinimum_HasValidCovariance(swigCPtr);
    return ret;
  }

  public bool HasAccurateCovar() {
    bool ret = Minuit2PINVOKE.FunctionMinimum_HasAccurateCovar(swigCPtr);
    return ret;
  }

  public bool HasPosDefCovar() {
    bool ret = Minuit2PINVOKE.FunctionMinimum_HasPosDefCovar(swigCPtr);
    return ret;
  }

  public bool HasMadePosDefCovar() {
    bool ret = Minuit2PINVOKE.FunctionMinimum_HasMadePosDefCovar(swigCPtr);
    return ret;
  }

  public bool HesseFailed() {
    bool ret = Minuit2PINVOKE.FunctionMinimum_HesseFailed(swigCPtr);
    return ret;
  }

  public bool HasCovariance() {
    bool ret = Minuit2PINVOKE.FunctionMinimum_HasCovariance(swigCPtr);
    return ret;
  }

  public bool IsAboveMaxEdm() {
    bool ret = Minuit2PINVOKE.FunctionMinimum_IsAboveMaxEdm(swigCPtr);
    return ret;
  }

  public bool HasReachedCallLimit() {
    bool ret = Minuit2PINVOKE.FunctionMinimum_HasReachedCallLimit(swigCPtr);
    return ret;
  }

  public void SetErrorDef(double up) {
    Minuit2PINVOKE.FunctionMinimum_SetErrorDef(swigCPtr, up);
  }

  public enum Status {
    MnValid,
    MnReachedCallLimit,
    MnAboveMaxEdm
  }

}
