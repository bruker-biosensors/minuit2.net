using FluentAssertions;
using minuit2.net;

namespace minuit2.UnitTests;

[Description("""
             Minimization results for various scenarios are validated through comparison with the output generated by 
             iminuit, the Minuit2 wrapper for Python.
             """)]
public class MinimizationResultTests
{
    private readonly Func<double, IList<double>, double> _cubicPoly = 
        (x, c) => c[0] + c[1] * x + c[2] * x * x + c[3] * x * x * x;
    
    private readonly List<double> _xValues = 
    [
        0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5
    ];

    // y-values are generated using a cubic polynomial with coefficients: c0 = 10, c1 = -2, c2 = 1, c3 = -0.1
    // and a random normal noise with a standard deviation of 0.1
    private readonly List<double> _yValues =
    [
        9.90108786, 9.20072133, 9.02879253, 8.93189744, 9.29202309, 9.74521038, 10.23635364, 11.01669522, 11.56834045,
        12.10526109, 12.50971673, 12.45990696, 12.51921661, 11.72039103, 10.80002694, 9.07613211, 6.95320331,
        3.77150306, 0.06882051, -4.45372309
    ];

    
    [Test]
    public void basic_scenario()
    {
        var cost = new LeastSquares(_xValues, _yValues, 0.1, _cubicPoly);
        
        var initialParameters = new UserParameters(
            new Parameter("c0", 7.79), 
            new Parameter("c1", -2.17), 
            new Parameter("c2", 1.15), 
            new Parameter("c3", -0.11));
        
        var minimizer = new Migrad(cost, initialParameters);
        var result = minimizer.Evaluate();

        result.Should().BeEquivalentTo([9.976261866327437, -1.9622541480976985, 0.9906196650169466, -0.09936114330982032], 
            options => options
                .Using<double>(ctx => ctx.Subject.Should().BeApproximately(ctx.Expectation, Math.Abs(ctx.Expectation * 0.001)))
                .WhenTypeIs<double>());
    }
}