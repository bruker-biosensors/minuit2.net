using FluentAssertions;
using minuit2.net;

namespace minuit2.UnitTests;

[Description("""
             Minimization results for various scenarios are validated through comparison with the output generated by 
             iminuit, the Minuit2 wrapper for Python.
             """)]
public class MinimizationResultTests
{
    private static IEnumerable<Func<double, IList<double>, IList<double>>?> GradientTestCases()
    {
        yield return null;
        yield return CubicPolynomial.ModelGradient;
    }
    
    [TestCaseSource(nameof(GradientTestCases))]
    public void basic_scenario(Func<double, IList<double>, IList<double>>? analyticalGradient)
    {
        var cost = CubicPolynomial.Cost.WithGradient(analyticalGradient).Build();

        var minimizer = new Migrad(cost, CubicPolynomial.ParameterConfigurations.Defaults);
        var result = minimizer.Run();

        result.Should()
            .HaveIsValid(true).And
            .HaveNumberOfVariables(4).And
            .HaveNumberOfFunctionCallsGreaterThan(10).And
            .HaveReachedFunctionCallLimit(false).And
            .HaveConverged(true).And
            .HaveCostValue(12.49).And
            .HaveParameters(["c0", "c1", "c2", "c3"]).And
            .HaveParameterValues([9.974, -1.959, 0.9898, -0.09931]).And
            .HaveParameterCovarianceMatrix(new[,]
            {
                { 0.005623, -0.004301, 0.000881, -5.271e-05 },
                { -0.004301, 0.004923, -0.001177, 7.655e-05 },
                { 0.000881, -0.001177, 0.0003037, -2.067e-05 },
                { -5.271e-05, 7.655e-05, -2.067e-05, 1.45e-06 }
            });
    }

    [TestCase(double.NegativeInfinity, double.PositiveInfinity)]
    [TestCase(double.NaN, double.PositiveInfinity)]
    [TestCase(double.NegativeInfinity, double.NaN)]
    [TestCase(double.NaN, double.NaN)]
    [Description("Ensure that the minimizer handles infinite bounds the same way as if there were no bounds")]
    public void basic_scenario_with_explicitly_provided_infinite_bounds(double lowerLimit, double upperLimit)
    {
        var cost = CubicPolynomial.Cost.Build();

        ParameterConfiguration[] parameterConfigurations =
        [
            CubicPolynomial.ParameterConfigurations.C0 with { LowerLimit = lowerLimit, UpperLimit = upperLimit },
            CubicPolynomial.ParameterConfigurations.C1 with { LowerLimit = lowerLimit, UpperLimit = upperLimit },
            CubicPolynomial.ParameterConfigurations.C2 with { LowerLimit = lowerLimit, UpperLimit = upperLimit },
            CubicPolynomial.ParameterConfigurations.C3 with { LowerLimit = lowerLimit, UpperLimit = upperLimit }
        ];
        
        var minimizer = new Migrad(cost, parameterConfigurations);
        var result = minimizer.Run();

        result.Should().HaveIsValid(true).And.HaveCostValue(12.49);
    }
    
    [TestCaseSource(nameof(GradientTestCases))]
    public void fixed_parameters_scenario(Func<double, IList<double>, IList<double>>? analyticalGradient)
    {
        var cost = CubicPolynomial.Cost.WithGradient(analyticalGradient).Build();
        
        ParameterConfiguration[] parameterConfigurations =
        [
            CubicPolynomial.ParameterConfigurations.C0,
            CubicPolynomial.ParameterConfigurations.C1 with {IsFixed = true},
            CubicPolynomial.ParameterConfigurations.C2,
            CubicPolynomial.ParameterConfigurations.C3 with {IsFixed = true}
        ];
        
        var minimizer = new Migrad(cost, parameterConfigurations);
        var result = minimizer.Run();

        result.Should()
            .HaveIsValid(true).And
            .HaveNumberOfVariables(2).And
            .HaveNumberOfFunctionCallsGreaterThan(10).And
            .HaveReachedFunctionCallLimit(false).And
            .HaveConverged(true).And
            .HaveCostValue(437.7).And
            .HaveParameters(["c0", "c1", "c2", "c3"]).And
            .HaveParameterValues([9.411, -1.97, 1.088, -0.11]).And
            .HaveParameterCovarianceMatrix(new[,]
            {
                { 0.001092, 0.0, -1.918e-05, 0.0 },
                { 0.0, 0.0, 0.0, 0.0 },
                { -1.918e-05, 0.0, 6.211e-07, 0.0 },
                { 0.0, 0.0, 0.0, 0.0 }
            });
    }

    [Test]
    public void limited_parameters_scenario()
    {
        var cost = CubicPolynomial.Cost.Build();

        ParameterConfiguration[] parameterConfigurations =
        [
            CubicPolynomial.ParameterConfigurations.C0 with { LowerLimit = CubicPolynomial.ParameterConfigurations.C0.Value - 0.25 },
            CubicPolynomial.ParameterConfigurations.C1,
            CubicPolynomial.ParameterConfigurations.C2,
            CubicPolynomial.ParameterConfigurations.C3 with { UpperLimit = CubicPolynomial.ParameterConfigurations.C3.Value + 0.005 }
        ];
        
        var minimizer = new Migrad(cost, parameterConfigurations);
        var result = minimizer.Run();

        result.Should()
            .HaveIsValid(true).And
            .HaveNumberOfVariables(4).And
            .HaveNumberOfFunctionCallsGreaterThan(10).And
            .HaveReachedFunctionCallLimit(false).And
            .HaveConverged(true).And
            .HaveCostValue(62.34).And
            .HaveParameters(["c0", "c1", "c2", "c3"]).And
            .HaveParameterValues([10.5, -2.39, 1.082, -0.105]).And
            .HaveParameterCovarianceMatrix(new[,]
            {
                { 7.023e-09, -3.654e-09, 3.124e-10, -1.261e-14 },
                { -3.654e-09, 0.0002602, -3.344e-05, 5.468e-09 },
                { 3.124e-10, -3.344e-05, 4.594e-06, -1.873e-09 },
                { -1.261e-14, 5.468e-09, -1.873e-09, 1.211e-10 }
            }, relativeTolerance: 0.003);  
    }
    
    [Test]
    public void limited_parameters_scenario_with_analytical_gradient()
    {
        var cost = CubicPolynomial.Cost.WithGradient(CubicPolynomial.ModelGradient).Build();
        
        ParameterConfiguration[] parameterConfigurations =
        [
            CubicPolynomial.ParameterConfigurations.C0 with { LowerLimit = CubicPolynomial.ParameterConfigurations.C0.Value - 0.25 },
            CubicPolynomial.ParameterConfigurations.C1,
            CubicPolynomial.ParameterConfigurations.C2,
            CubicPolynomial.ParameterConfigurations.C3 with { UpperLimit = CubicPolynomial.ParameterConfigurations.C3.Value + 0.005 }
        ];
        
        var minimizer = new Migrad(cost, parameterConfigurations);
        var result = minimizer.Run();

        result.Should()
            .HaveIsValid(true).And
            .HaveNumberOfVariables(4).And
            .HaveNumberOfFunctionCallsGreaterThan(10).And
            .HaveReachedFunctionCallLimit(false).And
            .HaveConverged(true).And
            .HaveCostValue(62.34).And
            .HaveParameters(["c0", "c1", "c2", "c3"]).And
            .HaveParameterValues([10.5, -2.39, 1.082, -0.105]).And
            .HaveParameterCovarianceMatrix(new[,]
            {
                { 5.482e-09, -2.933e-09, 2.507e-10, -7.976e-15 },
                { -2.933e-09, 0.0002602, -3.343e-05, 4.309e-09 },
                { 2.507e-10, -3.343e-05, 4.589e-06, -1.476e-09 },
                { -7.976e-15, 4.309e-09, -1.476e-09, 9.18e-11 }
            });
    }

    [TestCaseSource(nameof(GradientTestCases))]
    public void missing_data_uncertainties_scenario(Func<double, IList<double>, IList<double>>? analyticalGradient)
    {
        var cost = CubicPolynomial.Cost.WithMissingYErrors().WithGradient(analyticalGradient).Build();
        
        var minimizer = new Migrad(cost, CubicPolynomial.ParameterConfigurations.Defaults);
        var result = minimizer.Run();

        result.Should()
            .HaveIsValid(true).And
            .HaveNumberOfVariables(4).And
            .HaveNumberOfFunctionCallsGreaterThan(10).And
            .HaveReachedFunctionCallLimit(false).And
            .HaveConverged(true).And
            .HaveCostValue(0.1249).And
            .HaveParameters(["c0", "c1", "c2", "c3"]).And
            .HaveParameterValues([9.974, -1.959, 0.9898, -0.09931]).And
            .HaveParameterCovarianceMatrix(new[,]
            {
                { 0.004391, -0.003358, 0.0006878, -4.115e-05 },
                { -0.003358, 0.003843, -0.0009193, 5.977e-05 },
                { 0.0006878, -0.0009193, 0.0002371, -1.614e-05 },
                { -4.115e-05, 5.977e-05, -1.614e-05, 1.132e-06 }
            });
    }
    
    private static IEnumerable<object> CostFunctionWithErrorDefinitionDifferentFromOneTestCases()
    {
        yield return new object[] { CubicPolynomial.Cost.Build(), 4 };
        yield return new object[] { CubicPolynomial.Cost.WithMissingYErrors().Build(), 4 };
        yield return new object[] { CubicPolynomial.Cost.WithGradient(CubicPolynomial.ModelGradient).Build(), 4 };
        yield return new object[] { CubicPolynomial.Cost.WithGradient(CubicPolynomial.ModelGradient).WithMissingYErrors().Build(), 4 };
        yield return new object[] { CubicPolynomial.Cost.Build(), 9 };
    }
    
    [TestCaseSource(nameof(CostFunctionWithErrorDefinitionDifferentFromOneTestCases))]
    public void The_cost_value_of_a_minimization_result_should_be_independent_of_the_value_of_the_error_definition(
        LeastSquares referenceCost, double errorDefinition)
    {
        var cost = referenceCost.WithErrorDefinition(errorDefinition);
        
        var referenceResult = new Migrad(referenceCost, CubicPolynomial.ParameterConfigurations.Defaults).Run();
        var result = new Migrad(cost, CubicPolynomial.ParameterConfigurations.Defaults).Run();
        
        result.CostValue.Should().BeApproximately(referenceResult.CostValue, 1E-10);
    }
    
    [TestCaseSource(nameof(CostFunctionWithErrorDefinitionDifferentFromOneTestCases))]
    public void The_parameter_covariances_of_a_minimization_result_should_scale_with_the_error_definition(
        LeastSquares referenceCost, double errorDefinition)
    {
        var cost = referenceCost.WithErrorDefinition(errorDefinition);
        
        var referenceResult = new Migrad(referenceCost, CubicPolynomial.ParameterConfigurations.Defaults).Run();
        var result = new Migrad(cost, CubicPolynomial.ParameterConfigurations.Defaults).Run();
        
        result.ParameterCovarianceMatrix.Should().BeEquivalentTo(referenceResult.ParameterCovarianceMatrix.MultipliedBy(errorDefinition), 
            options => options
                .Using<double>(ctx => ctx.Subject.Should().BeApproximately(ctx.Expectation, Math.Abs(ctx.Expectation * 0.001)))
                .WhenTypeIs<double>());
    }
}