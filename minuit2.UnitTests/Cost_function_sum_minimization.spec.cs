using AwesomeAssertions;
using AwesomeAssertions.Execution;
using minuit2.net;
using minuit2.net.CostFunctions;
using minuit2.net.Minimizers;
using minuit2.UnitTests.TestUtilities;
using static minuit2.net.MinimizationExitCondition;
using static minuit2.net.ParameterConfiguration;

namespace minuit2.UnitTests;

public class A_cost_function_sum
{
    private readonly IMinimizer _minimizer = Minimizer.Migrad;
    
    [Test, Description("Ensures that auto-scaling of the error definition for cost functions with missing y-errors " +
                       "and, hence, parameter covariances works (on a per-cost basis).")]
    public void of_independent_components_with_some_components_having_unknown_data_errors_when_minimized_and_subsequently_passed_to_the_hesse_error_refinement_yields_a_result_equivalent_to_the_results_for_the_isolated_components(
        [Values] bool hasGradient, [Values] Strategy strategy)
    {
        if (strategy == Strategy.Fast)
            Assert.Ignore("The fast minimization strategy currently leads to inconsistent cost values, parameter values and covariances. " +
                          "This might be solved by using a lower tolerance for the minimizer and/or by calling the Hesse algorithm after minimization. " +
                          "This should be investigated, and if solvable should probably asserted in a separate test.");
        
        var component1 = CubicPolynomial.LeastSquaresCost.WithMissingYErrors().WithParameterSuffix(1).WithGradient(hasGradient).Build();
        var component2 = CubicPolynomial.LeastSquaresCost.WithParameterSuffix(2).WithGradient(hasGradient).Build();
        var sum = CostFunction.Sum(component1, component2);

        var parameterConfigurations1 = CubicPolynomial.ParameterConfigurations.DefaultsWithSuffix(1);
        var parameterConfigurations2 = CubicPolynomial.ParameterConfigurations.DefaultsWithSuffix(2);

        var minimizerConfiguration = new MinimizerConfiguration(strategy);
        var component1Result = MigradFollowedByHesse(component1, parameterConfigurations1, minimizerConfiguration);
        var component2Result = MigradFollowedByHesse(component2, parameterConfigurations2, minimizerConfiguration);
        var sumResult = MigradFollowedByHesse(sum, parameterConfigurations1.Concat(parameterConfigurations2).ToArray(), minimizerConfiguration);

        using (new AssertionScope())
        { 
            sumResult.Should()
                .HaveCostValue(component1Result.CostValue + component2Result.CostValue).And
                .HaveParameterValues(component1Result.ParameterValues.Concat(component2Result.ParameterValues).ToArray());
            
            const double relativeToleranceForNonZeros = 0.004;
            const double absoluteToleranceForZeros = 1e-8;
            sumResult.ParameterCovarianceMatrix.SubMatrix(0,3,0,3).Should().BeEquivalentTo(component1Result.ParameterCovarianceMatrix, options => options.WithRelativeDoubleTolerance(relativeToleranceForNonZeros));
            sumResult.ParameterCovarianceMatrix.SubMatrix(4,7,4,7).Should().BeEquivalentTo(component2Result.ParameterCovarianceMatrix, options => options.WithRelativeDoubleTolerance(relativeToleranceForNonZeros));
            sumResult.ParameterCovarianceMatrix.SubMatrix(4,7,0,3).Should().BeEquivalentTo(AllZeroMatrix(4,4), options => options.WithDoubleTolerance(absoluteToleranceForZeros));
            sumResult.ParameterCovarianceMatrix.SubMatrix(0,3,4,7).Should().BeEquivalentTo(AllZeroMatrix(4,4), options => options.WithDoubleTolerance(absoluteToleranceForZeros));
        }
    }

    private IMinimizationResult MigradFollowedByHesse(
        ICostFunction cost,
        ParameterConfiguration[] parameterConfigurations, 
        MinimizerConfiguration? minimizerConfiguration)
    {
        var result = _minimizer.Minimize(cost, parameterConfigurations, minimizerConfiguration);
        var adjustedCost = cost.WithErrorDefinitionAdjustedWhereRequiredBasedOn(result);
        return HesseErrorCalculator.Refine(result, adjustedCost);
    }

    private static double[,] AllZeroMatrix(int rows, int columns) => new double[rows, columns];

    [TestCase(false, false, 182),
     TestCase(true, false, 182),
     TestCase(true, true, 120),
     Description("Expected values are generated by iminuit, the Minuit2 wrapper for Python, for the same scenario.")]
    public void with_all_components_having_defined_data_uncertainties_when_minimized_yields_the_expected_result(
        bool hasFirstGradient, bool hasLastGradient, int expectedFunctionCalls)
    {
        var cost = CostFunction.Sum(
            CubicPolynomial.LeastSquaresCost.WithGradient(hasFirstGradient).Build(),
            CubicPolynomial.LeastSquaresCost.WithParameterNames(c1: "c1_1", c3: "c3_1").WithGradient(hasLastGradient).Build());
        var parameterConfigurations = CubicPolynomial.ParameterConfigurations.Defaults
            .Concat([Variable("c1_1", -2.1), Variable("c3_1", -0.15)]).ToArray();

        var result = _minimizer.Minimize(cost, parameterConfigurations);

        result.Should()
            .HaveExitCondition(Converged).And
            .HaveIsValid(true).And
            .HaveNumberOfVariables(6).And
            .HaveNumberOfFunctionCallsCloseTo(expectedFunctionCalls).And
            .HaveCostValue(24.99).And
            .HaveParameters(["c0", "c1", "c2", "c3", "c1_1", "c3_1"]).And
            .HaveParameterValues([9.974, -1.959, 0.9898, -0.09931, -1.959, -0.09931]).And
            .HaveParameterCovarianceMatrix(new[,]
            {
                { 0.002811, -0.00215, 0.0004404, -2.635e-05, -0.00215, -2.635e-05 },
                { -0.00215, 0.002512, -0.0005887, 3.752e-05, 0.00241, 3.902e-05 },
                { 0.0004404, -0.0005887, 0.0001518, -1.033e-05, -0.0005887, -1.033e-05 },
                { -2.635e-05, 3.752e-05, -1.033e-05, 7.383e-07, 3.902e-05, 7.12e-07 },
                { -0.00215, 0.00241, -0.0005887, 3.902e-05, 0.002512, 3.752e-05 },
                { -2.635e-05, 3.902e-05, -1.033e-05, 7.12e-07, 3.752e-05, 7.384e-07 }
            });
    }
    
    [Test, Description("Expected values are generated by iminuit, the Minuit2 wrapper for Python, for the same scenario.")]
    public void with_some_components_having_missing_data_errors_when_minimized_yields_the_expected_result(
        [Values] bool hasFirstGradient, [Values] bool hasLastGradient)
    {
        var cost = CostFunction.Sum(
            CubicPolynomial.LeastSquaresCost.WithGradient(hasFirstGradient).Build(),
            CubicPolynomial.LeastSquaresCost.WithMissingYErrors().WithGradient(hasLastGradient).Build());

        var result = _minimizer.Minimize(cost, CubicPolynomial.ParameterConfigurations.Defaults);

        result.Should()
            .HaveExitCondition(Converged).And
            .HaveIsValid(true).And
            .HaveNumberOfVariables(4).And
            .HaveCostValue(12.62).And
            .HaveParameters(["c0", "c1", "c2", "c3"]).And
            .HaveParameterValues([9.974, -1.959, 0.9898, -0.09931]).And
            .HaveParameterCovarianceMatrix(new[,]
            {
                { 0.005567, -0.004258, 0.0008721, -5.218e-05 },
                { -0.004258, 0.004873, -0.001166, 7.578e-05 },
                { 0.0008721, -0.001166, 0.0003006, -2.046e-05 },
                { -5.218e-05, 7.578e-05, -2.046e-05, 1.436e-06 }
            });
    }
    
    [Test, Description("Expected values are generated by iminuit, the Minuit2 wrapper for Python, for the same scenario. " +
                       "Ensures parameter covariances are auto-scaled only for the (inner) cost functions with missing y-errors.")]
    public void with_some_components_having_unknown_data_errors_when_minimized_and_subsequently_passed_to_the_hesse_error_refinement_yields_the_expected_result(
        [Values] bool hasFirstGradient, [Values] bool hasLastGradient)
    {
        var cost = CostFunction.Sum(
            CubicPolynomial.LeastSquaresCost.WithGradient(hasFirstGradient).Build(),
            CubicPolynomial.LeastSquaresCost.WithMissingYErrors().WithGradient(hasLastGradient).Build());

        var result = MigradFollowedByHesse(cost, CubicPolynomial.ParameterConfigurations.Defaults, null);

        result.Should()
            .HaveExitCondition(Converged).And
            .HaveIsValid(true).And
            .HaveNumberOfVariables(4).And
            .HaveCostValue(12.62).And
            .HaveParameters(["c0", "c1", "c2", "c3"]).And
            .HaveParameterValues([9.974, -1.959, 0.9898, -0.09931]).And
            .HaveParameterCovarianceMatrix(new[,]
            {
                { 0.002465, -0.001886, 0.0003862, -2.311e-05 },
                { -0.001886, 0.002158, -0.0005162, 3.356e-05 },
                { 0.0003862, -0.0005162, 0.0001331, -9.062e-06 },
                { -2.311e-05, 3.356e-05, -9.062e-06, 6.359e-07 }
            });
    }
}