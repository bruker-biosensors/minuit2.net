using FluentAssertions;
using minuit2.net;
using minuit2.UnitTests.TestUtilities;

namespace minuit2.UnitTests;

public class A_cost_function
{
    [Test, Description("Ensures correct parameter-configuration-to-cost-function-parameter mapping.")]
    public void when_minimized_yields_the_same_result_independent_of_the_order_parameter_configurations_are_provided_in()
    {
        var cost = CubicPolynomial.LeastSquaresCost.Build();
        var orderedConfigurations = CubicPolynomial.ParameterConfigurations.Defaults; 
        var disorderedConfigurations = CubicPolynomial.ParameterConfigurations.Defaults.InRandomOrder().ToArray();
        
        var resultForOrderedConfigurations = MigradMinimizer.Minimize(cost, orderedConfigurations);
        var resultForDisorderedConfigurations = MigradMinimizer.Minimize(cost, disorderedConfigurations);
        
        resultForDisorderedConfigurations.Should().BeEquivalentTo(resultForOrderedConfigurations);
    }
    
    [TestCase(double.NegativeInfinity, double.PositiveInfinity)]
    [TestCase(double.NaN, double.PositiveInfinity)]
    [TestCase(double.NegativeInfinity, double.NaN)]
    [TestCase(double.NaN, double.NaN)]
    [Description("Ensures minimizer handles infinite parameter limits the same way as if there were no limits.")]
    public void can_be_minimized_with_infinite_parameter_limits(double lowerLimit, double upperLimit)
    {
        var cost = CubicPolynomial.LeastSquaresCost.Build();

        ParameterConfiguration[] parameterConfigurations =
        [
            CubicPolynomial.ParameterConfigurations.C0 with { LowerLimit = lowerLimit, UpperLimit = upperLimit },
            CubicPolynomial.ParameterConfigurations.C1 with { LowerLimit = lowerLimit, UpperLimit = upperLimit },
            CubicPolynomial.ParameterConfigurations.C2 with { LowerLimit = lowerLimit, UpperLimit = upperLimit },
            CubicPolynomial.ParameterConfigurations.C3 with { LowerLimit = lowerLimit, UpperLimit = upperLimit }
        ];

        var result = MigradMinimizer.Minimize(cost, parameterConfigurations);
        
        result.Should().HaveIsValid(true);
    }
    
       private static IEnumerable<object> CostFunctionWithErrorDefinitionDifferentFromOneTestCases()
    {
        yield return new object[] { CubicPolynomial.LeastSquaresCost.Build(), 4 };
        yield return new object[] { CubicPolynomial.LeastSquaresCost.WithMissingYErrors().Build(), 4 };
        yield return new object[] { CubicPolynomial.LeastSquaresCost.WithGradient().Build(), 4 };
        yield return new object[] { CubicPolynomial.LeastSquaresCost.WithGradient().WithMissingYErrors().Build(), 4 };
        yield return new object[] { CubicPolynomial.LeastSquaresCost.Build(), 9 };
    }
    
    [TestCaseSource(nameof(CostFunctionWithErrorDefinitionDifferentFromOneTestCases))]
    public void when_minimized_yields_the_same_cost_value_independent_of_its_error_definition(
        LeastSquares referenceCost, double errorDefinition)
    {
        var cost = referenceCost.WithErrorDefinition(errorDefinition);
        
        var referenceResult = MigradMinimizer.Minimize(referenceCost, CubicPolynomial.ParameterConfigurations.Defaults);
        var result = MigradMinimizer.Minimize(cost, CubicPolynomial.ParameterConfigurations.Defaults);
        
        result.CostValue.Should().BeApproximately(referenceResult.CostValue, 1E-10);
    }
    
    [TestCaseSource(nameof(CostFunctionWithErrorDefinitionDifferentFromOneTestCases))]
    public void when_minimized_yields_parameter_covariances_that_directly_scale_with_the_error_definition(
        LeastSquares referenceCost, double errorDefinition)
    {
        var cost = referenceCost.WithErrorDefinition(errorDefinition);
        
        var referenceResult = MigradMinimizer.Minimize(referenceCost, CubicPolynomial.ParameterConfigurations.Defaults);
        var result = MigradMinimizer.Minimize(cost, CubicPolynomial.ParameterConfigurations.Defaults);
        
        result.ParameterCovarianceMatrix.Should().BeEquivalentTo(referenceResult.ParameterCovarianceMatrix.MultipliedBy(errorDefinition), 
            options => options.WithRelativeDoubleTolerance(0.001));
    }
    
    [TestCase(false, 100),
     TestCase(true, 78),
     Description("Expected values are generated by iminuit, the Minuit2 wrapper for Python, for the same scenario.")]
    public void when_minimized_yields_the_expected_result(bool hasGradient, int expectedFunctionCalls)
    {
        var cost = CubicPolynomial.LeastSquaresCost.WithGradient(hasGradient).Build();

        var result = MigradMinimizer.Minimize(cost, CubicPolynomial.ParameterConfigurations.Defaults);

        result.Should()
            .HaveIsValid(true).And
            .HaveNumberOfVariables(4).And
            .HaveNumberOfFunctionCallsCloseTo(expectedFunctionCalls).And
            .HaveReachedFunctionCallLimit(false).And
            .HaveConverged(true).And
            .HaveCostValue(12.49).And
            .HaveParameters(["c0", "c1", "c2", "c3"]).And
            .HaveParameterValues([9.974, -1.959, 0.9898, -0.09931]).And
            .HaveParameterCovarianceMatrix(new[,]
            {
                { 0.005623, -0.004301, 0.000881, -5.271e-05 },
                { -0.004301, 0.004923, -0.001177, 7.655e-05 },
                { 0.000881, -0.001177, 0.0003037, -2.067e-05 },
                { -5.271e-05, 7.655e-05, -2.067e-05, 1.45e-06 }
            });
    }
    
    [TestCase(false, 31),
     TestCase(true, 31),
     Description("Expected values are generated by iminuit, the Minuit2 wrapper for Python, for the same scenario.")]
    public void when_minimized_with_fixed_parameters_yields_the_expected_result(bool hasGradient, int expectedFunctionCalls)
    {
        var cost = CubicPolynomial.LeastSquaresCost.WithGradient(hasGradient).Build();
        
        ParameterConfiguration[] parameterConfigurations =
        [
            CubicPolynomial.ParameterConfigurations.C0,
            CubicPolynomial.ParameterConfigurations.C1 with {IsFixed = true},
            CubicPolynomial.ParameterConfigurations.C2,
            CubicPolynomial.ParameterConfigurations.C3 with {IsFixed = true}
        ];

        var result = MigradMinimizer.Minimize(cost, parameterConfigurations);

        result.Should()
            .HaveIsValid(true).And
            .HaveNumberOfVariables(2).And
            .HaveNumberOfFunctionCallsCloseTo(expectedFunctionCalls).And
            .HaveReachedFunctionCallLimit(false).And
            .HaveConverged(true).And
            .HaveCostValue(437.7).And
            .HaveParameters(["c0", "c1", "c2", "c3"]).And
            .HaveParameterValues([9.411, -1.97, 1.088, -0.11]).And
            .HaveParameterCovarianceMatrix(new[,]
            {
                { 0.001092, 0.0, -1.918e-05, 0.0 },
                { 0.0, 0.0, 0.0, 0.0 },
                { -1.918e-05, 0.0, 6.211e-07, 0.0 },
                { 0.0, 0.0, 0.0, 0.0 }
            });
    }

    [Test, Description("Expected values are generated by iminuit, the Minuit2 wrapper for Python, for the same scenario.")]
    public void when_minimized_with_limited_parameters_yields_the_expected_result()
    {
        var cost = CubicPolynomial.LeastSquaresCost.Build();

        ParameterConfiguration[] parameterConfigurations =
        [
            CubicPolynomial.ParameterConfigurations.C0 with { LowerLimit = CubicPolynomial.ParameterConfigurations.C0.Value - 0.25 },
            CubicPolynomial.ParameterConfigurations.C1,
            CubicPolynomial.ParameterConfigurations.C2,
            CubicPolynomial.ParameterConfigurations.C3 with { UpperLimit = CubicPolynomial.ParameterConfigurations.C3.Value + 0.005 }
        ];

        var result = MigradMinimizer.Minimize(cost, parameterConfigurations);

        result.Should()
            .HaveIsValid(true).And
            .HaveNumberOfVariables(4).And
            .HaveNumberOfFunctionCallsCloseTo(444).And
            .HaveReachedFunctionCallLimit(false).And
            .HaveConverged(true).And
            .HaveCostValue(62.34).And
            .HaveParameters(["c0", "c1", "c2", "c3"]).And
            .HaveParameterValues([10.5, -2.39, 1.082, -0.105]).And
            .HaveParameterCovarianceMatrix(new[,]
            {
                { 7.023e-09, -3.654e-09, 3.124e-10, -1.261e-14 },
                { -3.654e-09, 0.0002602, -3.344e-05, 5.468e-09 },
                { 3.124e-10, -3.344e-05, 4.594e-06, -1.873e-09 },
                { -1.261e-14, 5.468e-09, -1.873e-09, 1.211e-10 }
            }, relativeTolerance: 0.003);  
    }
    
    [Test, Description("Expected values are generated by iminuit, the Minuit2 wrapper for Python, for the same scenario; " +
                       "That the resulting parameter covariances are different from the numerical-gradient case (above) " +
                       "is due to terminating at the parameter limits; Covariances are not robust/trustworthy in this situation.")]
    public void with_an_analytical_gradient_when_minimized_with_limited_parameters_yields_the_expected_result()
    {
        var cost = CubicPolynomial.LeastSquaresCost.WithGradient().Build();
        
        ParameterConfiguration[] parameterConfigurations =
        [
            CubicPolynomial.ParameterConfigurations.C0 with { LowerLimit = CubicPolynomial.ParameterConfigurations.C0.Value - 0.25 },
            CubicPolynomial.ParameterConfigurations.C1,
            CubicPolynomial.ParameterConfigurations.C2,
            CubicPolynomial.ParameterConfigurations.C3 with { UpperLimit = CubicPolynomial.ParameterConfigurations.C3.Value + 0.005 }
        ];

        var result = MigradMinimizer.Minimize(cost, parameterConfigurations);

        result.Should()
            .HaveIsValid(true).And
            .HaveNumberOfVariables(4).And
            .HaveNumberOfFunctionCallsCloseTo(156).And
            .HaveReachedFunctionCallLimit(false).And
            .HaveConverged(true).And
            .HaveCostValue(62.34).And
            .HaveParameters(["c0", "c1", "c2", "c3"]).And
            .HaveParameterValues([10.5, -2.39, 1.082, -0.105]).And
            .HaveParameterCovarianceMatrix(new[,]
            {
                { 5.482e-09, -2.933e-09, 2.507e-10, -7.976e-15 },
                { -2.933e-09, 0.0002602, -3.343e-05, 4.309e-09 },
                { 2.507e-10, -3.343e-05, 4.589e-06, -1.476e-09 },
                { -7.976e-15, 4.309e-09, -1.476e-09, 9.18e-11 }
            });
    }

    [Test, Description("Expected values are generated by iminuit, the Minuit2 wrapper for Python, for the same scenario.")]
    public void with_missing_data_uncertainties_when_minimized_yields_the_expected_result([Values] bool hasGradient)
    {
        var cost = CubicPolynomial.LeastSquaresCost.WithMissingYErrors().WithGradient(hasGradient).Build();

        var result = MigradMinimizer.Minimize(cost, CubicPolynomial.ParameterConfigurations.Defaults);

        result.Should()
            .HaveIsValid(true).And
            .HaveNumberOfVariables(4).And
            .HaveReachedFunctionCallLimit(false).And
            .HaveConverged(true).And
            .HaveCostValue(0.1249).And
            .HaveParameters(["c0", "c1", "c2", "c3"]).And
            .HaveParameterValues([9.974, -1.959, 0.9898, -0.09931]).And
            .HaveParameterCovarianceMatrix(new[,]
            {
                { 0.004391, -0.003358, 0.0006878, -4.115e-05 },
                { -0.003358, 0.003843, -0.0009193, 5.977e-05 },
                { 0.0006878, -0.0009193, 0.0002371, -1.614e-05 },
                { -4.115e-05, 5.977e-05, -1.614e-05, 1.132e-06 }
            });
    }
    
    [Test]
    public void when_minimized_forwards_exceptions_thrown_by_the_model_function()
    {
        var cost = new LeastSquares([0], [0], 0, [], ModelFunctionThrowing<TestException>());
        Action action = () => MigradMinimizer.Minimize(cost, []);
        action.Should().ThrowExactly<TestException>();
    }

    private static Func<double, IList<double>, double> ModelFunctionThrowing<T>() where T : Exception, new()
        => (_, _) => throw new T();
    
    private class TestException : Exception;
}